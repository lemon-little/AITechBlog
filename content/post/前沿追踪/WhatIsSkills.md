# What Is Skills?

## 从热潮到反思

2025 年底，Anthropic 提出了 Skills 这个新概念，AI 应用领域随即掀起了新一波开发浪潮。各家厂商纷纷宣传自己支持 Skills 的能力，开发者们也在积极尝试。

然而，在无脑跟风实践了一段时间后，我开始向自己提问：**Skills 到底是什么？如果让我来定义 Skills，我会如何定义它？**

## Skills 的本质

### 核心问题：Token 效率

要理解 Skills，首先要理解它解决的核心问题——**如何用最少的 Token 办最多的事**。

在传统的 Prompt 工程中，我们往往需要在每次对话中携带大量的上下文信息、指令和示例。这不仅消耗大量 Token，还会导致：

- 响应速度下降
- 成本增加
- 上下文窗口被快速占满

### 解决方案：动态提示词构建

Skills 的本质是**按照能力范围拆解提示词进行打包，对不同的 Skills 互相保留指针，然后实时按需导入，实现动态提示词构建**。

这种按需导入的方式，让 Skills 成为一个可组合的模块，方便在不同的场景下灵活使用。

<!-- 图示 1：Skills 动态加载机制 -->
```
┌─────────────┐
│  用户请求    │
└──────┬──────┘
       ▼
┌─────────────┐
│  意图识别    │
└──────┬──────┘
       ▼
┌─────────────────────────────┐
│     Skills 索引表            │
│  ┌───┐ ┌───┐ ┌───┐ ┌───┐   │
│  │ A │ │ B │ │ C │ │ D │   │
│  └───┘ └───┘ └───┘ └───┘   │
└─────────────────────────────┘
       ▼ (按需加载 A, C)
┌─────────────────────────────┐
│  动态构建的 Prompt           │
│  [基础指令] + [Skill A] +   │
│  [Skill C] + [用户输入]     │
└─────────────────────────────┘
       ▼
┌─────────────┐
│  LLM 执行    │
└─────────────┘

绘制指导：
- 类型：流程图
- 工具推荐：draw.io / Excalidraw / Mermaid
- 要点：突出"按需加载"的动态特性
```

## 软件工程的既视感

Skills 的出现，让 **Prompt Engineering 成为一件和传统软件工程一样可以"搭积木"的事情**。

这让我想起了最初学习编程时的场景：当代码量增长到一定程度，我们开始学习如何将代码拆分到多个源文件中，通过 `import`、`include`、`require` 等方式按需引入。

一些编程语言支持"调用时才导入"的特性（如 Python 的延迟导入），这与 Skills 的按需加载理念不谋而合。软件工程中积累的模块化、解耦、复用等理念，在 Skills 时代将更加发挥作用。

<!-- 图示 2：传统软件模块化 vs Skills 模块化对比 -->
```
传统软件工程                    Skills 工程
┌────────────────────┐         ┌────────────────────┐
│     main.py        │         │   Agent Prompt     │
│  ┌──────────────┐  │         │  ┌──────────────┐  │
│  │ import utils │──┼──→      │  │ @code_review │──┼──→ code_review.skill
│  │ import db    │──┼──→      │  │ @debugging   │──┼──→ debugging.skill
│  │ import api   │──┼──→      │  │ @refactor    │──┼──→ refactor.skill
│  └──────────────┘  │         │  └──────────────┘  │
│    业务逻辑...      │         │    基础指令...      │
└────────────────────┘         └────────────────────┘

        相同的模块化思想，不同的载体

绘制指导：
- 类型：对比图（左右并列）
- 工具推荐：draw.io / Figma
- 要点：强调两者的相似性，用箭头表示导入关系
```

## Skills 生态的未来

既然 Skills 本质上是可复用的能力模块，那么自然会催生出 **Skills 管理框架**的需求。

想想我们熟悉的包管理工具：

- Python 的 `pip` / `uv`
- JavaScript 的 `npm` / `yarn`
- Rust 的 `cargo`

这些工具帮助我们发布和分享代码包、管理依赖关系、进行版本控制、避免重复造轮子。

也许某天，也许就是现在，Skills 管理框架正在应运而生。它将帮助我们管理不同的 Skills，避免重复开发，共享最佳实践，提高开发效率。

<!-- 图示 3：Skills 生态系统架构 -->
```
┌─────────────────────────────────────────┐
│           Skills Registry               │
│    (类似 npm registry / PyPI)           │
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐       │
│  │skill│ │skill│ │skill│ │skill│ ...   │
│  └─────┘ └─────┘ └─────┘ └─────┘       │
└───────────────────┬─────────────────────┘
                    │
        ┌───────────┼───────────┐
        ▼           ▼           ▼
┌───────────┐ ┌───────────┐ ┌───────────┐
│  skills   │ │  skills   │ │  skills   │
│  install  │ │  update   │ │  publish  │
└───────────┘ └───────────┘ └───────────┘
        │           │           │
        └───────────┼───────────┘
                    ▼
        ┌─────────────────────┐
        │   Local Skills      │
        │   Management        │
        │  ┌───┐ ┌───┐ ┌───┐  │
        │  │ A │ │ B │ │ C │  │
        │  └───┘ └───┘ └───┘  │
        └─────────────────────┘
                    │
                    ▼
        ┌─────────────────────┐
        │    Your AI Agent    │
        └─────────────────────┘

绘制指导：
- 类型：架构图
- 工具推荐：draw.io / Excalidraw
- 要点：展示从云端 Registry 到本地管理再到 Agent 的完整链路
```

## 总结

Skills 不是一个全新的概念，而是**软件工程模块化思想在 AI 时代的延续和进化**。它的核心价值在于：

1. **效率**：用最少的 Token 完成最多的任务
2. **复用**：将能力封装成可复用的模块
3. **协作**：让 PE 工程可以像软件开发一样分工协作

当我们理解了 Skills 的本质，就能更好地设计、开发和管理我们的 AI 应用。
